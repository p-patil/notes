	processes and threads

1. Processes
In order to facilitate the ability to run multiple applications at once on a single computer, the operating system defines the processor abstraction to encapsulate a running instance of a computer program, and as such contains the execution code, the process' current activity, and various system meta-details (such as program state, which is composed of the stack pointer, register values, the program counter, the address space, the process state (new (process is being created), running (process is executing), waiting (process is waiting for some event to occur), ready (process is waiting to use CPU), or terminated (process is done executing)) etc.) relevant to the execution of the process. Each process runs in its own address space and has its own state of execution with respect to the OS' management of that process.

In full, between the OS and the process abstraction, process meta-information keeps track of a process' own virtual address space, its executable code, its open handles to system objects (such as files), its security context and permissions, its (unique) process identifier, its environment variables, its priority (and priority class), its (minimum and maximum) working set sizes, and its threads of execution (of which there's necessarily at least one). All of this information pertaining to and characterizing a process is tracked by the kernel in a data structure called a process control block (PCB); because PCBs define the process they represent, it's often said that the set of PCBs defines the current state of the operating system, as it encloses all running processes and their respective execution contexts. The OS schedules different processes, giving them their own slices of time on the CPU, accounting for process priority, and interleaving processes concurrently as they wait for events such as I/O operations.

Because of the way processes are encapsulated, they are completely managed by and communicate with the OS - this means that processes must go through the OS to communicate with other processes, through a channel known as inter-process communication (IPC). Processes are created by other processes, and by default are the child process of their parent process. This involves the duplication of the parent process, e.g. in order to give the child process a copy of the parent processes' data segment of memory.

2. Threads
Threads, on the other hand, are abstractions contained within processes. They are the smallest executable units of code, and encapsulate a sequence of instructions to execute on the CPU and an associated full execution context (such as register values, program counter, stack pointer, etc.). The process abstraction contains, often multiple, threads and uses them to execute different, conceptually partitioned units of code which each has an atomic purpose (for example, a word processor such as Microsoft Word might run in a single process (though in reality, full applications in fact often utilize multiple processes), representing the application's execution on the processor chip, but might encapsulate multiple threads of code execution, e.g. one for rendering graphics and the text, one for reading keystrokes from user input, one for performing spelling and grammar checks in the background, etc.). Whereas processes are designed to conform to OS scheduling and time-sharing, the thread abstraction is meant to run under the illusion of parallelism; in other words, the OS should allow for the conceptual assumption that different threads in a process run in parallel.

Threads differ from processes in many ways. The different threads within a process run in a shared address space, whereas different processes each have their own unique address space. Threads within a process can communicate directly with each other instead of having to go through the (expensive) IPC channel. They also have very little overhead in getting started, while processes, due to the amount of meta-information and OS management details necessary to start one up, are expensive to create. For the same reason, running a new process is a more expensive endeavor for the OS than running a new thread, as the former consumes more resources and requires the OS to manage it. The threads of a process also don't have as rigid of a parent-child hierarchy as processes; whereas processes can only influence child processes, threads can more or less exert influence over all other threads in their containing process.

3. Conclusion
Fundamentally, threads represent the units of executing code along with their full enclosing execution context, and thus correspond between an application and what is actually running on a CPU; because threads share resources and access the same memory, they are highly efficient, have low overhead, and overall have good performance, but such a strategy leaves gaping security holes and leaves both user programs unprotected from each other and the OS unprotected from programs; consequently, processes exist primarily to provide a layer of security and protection between programs and between the OS and programs, encapsulating threads and being completely controlled by the OS.
