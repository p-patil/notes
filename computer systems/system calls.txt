	system calls

1. Motivation: Security and Fault-Tolerance

Modern computer architectures typically involve a security model, designed to prevent userspace processes from disrupting the hardware or activity of the operating system or crashing the entire computer. Both for fault tolerance and for security against malicious attacks, processes are designed to run within a certain isolated CPU mode, wherein they are allowed as much access to consume and manipulate resources as necessary, but not more. Processes have certain permissions levels which govern what they can and cannot do, with respect to low-level system abstractions and hardware.

Only the kernel is at the highest level of privilege, with complete control and access to the entire hardware of the system. In fact, the kernel's elevated, maximal permissions are often implemented at the hardware level. The CPU runs in certain, software-specified, modes; the fully unrestricted mode that kernel code runs in is called kernel mode. In kernel mode, the CPU is able to execute any and every operation allowable by its architecture, call for any I/O operation, access any part of memory, etc. In other CPU modes, the hardware enforces restrictions on what the code the CPU is running can do, such as barring certain instructions from running or accessing certain parts of memory.

Often, a multitude of CPU modes are supported (rather than just "kernel mode" and "user mode", for example). These modes form hierarchical levels of permissions, with greater access and capability the closer the permissions level is to kernel mode. These levels are known as protection rings, referring to the graphical model of permissions as concentric circles with kernel mode in the center and the least trusted mode at the very edge. The levels of permissions are referred to as rings, with ring 0 being kernel mode by convention (so, the higher the ring number, the lower the permissions). Because protection rings are enforced at the hardware level, code running in a higher ring is physically unable to execute certain instructions, as the CPU is blocked by actual hardware from doing so. Typically, there are four rings:

Ring 0: kernel mode
Ring 1: Trusted device drivers
Ring 2: Less trusted device drivers
Ring 3: Userspace applications

There are tightly controlled gates between rings that allow programs running in one ring to perform actions native to a lower ring, but such access is heavily regulated.

2. System Calls

Because userspace programs run in a higher protection ring than the kernel, despite the kernel having unique access to certain commonly used, often necessary, hardware (such as the screen, speakers, etc.), a mechanism for allowing programs to request certain services from the kernel (since the program might be unable to perform the service itself due to its higher ring number). The system call is the programmatic gate between ring 3 and lower rings, and provides the software abstraction for programs to make requests from the kernel, such as accessing certain hardware (eg disk), creating a child process, printing to a screen, getting information from the kernel about kernel services such as process scheduling, accessing the network interface to connect to the Internet, etc. The execution of a system call transfers control of execution to the kernel and puts the CPU in kernel mode, allowing the kernel to execute the necessary code, often with parameters passed to the system call, before switching back to user mode, locking out kernel space, and returning control to the original process. System calls are each assigned unique numbers, and form an immutable set of low-level instructions. The mechanism of actually transferring control is typically implemented with a software interrupt; since interrupts, by their very definitional nature, transfer control to the kernel anyways, the implementation of a system call simply requires a special, dedicated register to hold the number of the system call to be executed, along with registers or other means of holding parameters, followed by a software interrupt. Certain modern instruction set architectures offer specialized instructions (eg SYSCALL/SYSRET in AMD processors or SYSENTER/SYSEXIT in Intel processors) which, through specialized hardware, allow the transfer of control from process to kernel to be very fast, and skip the overhead of an interrupt.

Thus, system calls represent clearly defined, direct entry points into certain pre-determined kernel services, acting as gates from ring 3 to ring 0 to allow processes to piggyback on the kernel's elevated privilege to execute certain restricted code in a heavily regulated way. Modern OS's offer a variety of system calls, each mapping onto a specific kernel service, but system calls can be broadly by purpose classified into six groups: process management, interprocess communication, memory management, file system, initialization and other.