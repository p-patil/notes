	interrupts

1. Introduction
There are many different high-priority events that might occur at any given moment in time, often unpredictably (as they may be the result of interaction with the outside world, such as a network or the user, over which internal software has no knowledge or control), which might require the processor to deal with immediately. To avoid resource-heavy polling loops, interrupts exist as signals to the processor that a high-priority event has occurred. Interrupts are characterized by their interrupt number and a corresponding built-in function called the interrupt handler - when an interrupt occurs, the processor reacts by halting its current execution thread, saving its state (by pushing the contents of its registers and local variables to memory) and executing the corresponding interrupt handler.

2. Software vs Hardware interrupts
There are two kinds of interrupts: hardware interrupts and software interrupts. The former, hardware interrupts, are used by hardware devices within the computer system, such as networking cards, the keyboard, the graphics chip, etc., to communicate with the operating system when they require immediate attention by the central processor (i.e. the CPU), possibly an externally peripheral device. For example, this is how the OS handles keyboard processes or mouse movement. Hardware interrupts are thus asynchronous, since devices distinct and separate from the CPU are working (in parallel) on their respective tasks (e.g. the keyboard is recording keystrokes, the networking card is polling for incoming data from a network, etc.) and, completely separate from the current activity of the CPU, initiate interrupts when they intercept a high-priority event requiring immediate processing by the CPU. In contrast, software interrupts are synchronous and are initiated by the code that's executing within the processor itself. Specifically, they can be initiated by either the code running in the processor, as a software exception that's intentionally thrown, or by the processor when attempting to execute some forbidden instruction (e.g. a divide-by-zero instruction). The operating system catches software exceptions and chooses how to proceed and whether to abort the program that threw or caused the exception.

3. Implementation
Chronologically, hardware interrupts are the initial interrupts and predate software interrupts. Interrupts were originally introduced as hardware optimizations to eliminate the need for the CPU to undergo polling loops to check for high-priority events. Thus, hardware interrupts are implemented in the hardware itself - devices intrinsic to the computer, or external peripheral devices, other than the CPU are connected to the central processor's interrupt pin, through an interrupt controller circuit which multiplexes all the different interrupt lines from the different devices into the processor. Alternatively, it's not uncommon for interrupts to be implemented not through a dedicated interrupt controller circuit but through the existing memory controller circuit, whose job is primarily to manage data flow to and from the computer's memory, at a hardware level. In this case, interrupts are mapped into the memory's address space.

Each hardware device is connected to its own IRQ (interrupt request) circuit, or line, through which signals are automatically transmitted to the processor's interrupt controller, which then triggers the processor to save its state and switch to executing the corresponding interrupt handler, which are essentially a static block of built-in subroutines within the kernel. Interrupts are identified by an ID; there is a static data structure, called the interrupt vector table (IVT), which associates a list of interrupt handlers with interrupt requests. Entries in the IVT are called interrupt vectors, and store the address of the respective interrupt handler function code.

Software interrupts, on the other hand, are handled similarly to hardware interrupts but can only be generated by processes that are already running, and thus are generated synchronously by current processes and not asynchronously by hardware devices. Most software interrupts are for I/O (usually disk input/output).